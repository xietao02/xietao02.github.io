[{"title":"C++基础语法部分总结","url":"/basic_cpp.html","content":"超级基础的语法部分，入门必备。完结撒花*(੭ˊᵕˋ)੭ଘ…\n\n\n变量和基本类型默认初始化如果定义变量时没有指定初始值，那么变量将进行默认初始化，默认值由变量的类型决定，同时定义变量的位置也会对此产生影响。\n定义于任何函数外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。\nconst 限定符const与引用在定义引用时，程序把引用和它的初始值绑定在一起，而非拷贝一份值赋给引用，所以无法令引用重新绑定到另外一个新的对象，因此引用必须初始化。\n引用分为普通引用和常量引用，其中常量引用不能被用作修改它所绑定的对象。\n\n普通引用：引用的类型必须与其所引用对象的类型一致。\n\n常量引用：可以绑定常量对象以及非常量的对象，并且在初始化常量引用时允许使用任意表达式作为初始值，\n\n\n指针、const和类型别名int const *p = &amp;x;\t\t\t//指针p指向一个int型常量const int *p = &amp;x;\t\t\t//同上int *const p = &amp;x;\t\t\t//指针p将一直指向x，即常量指针const int *const p = &amp;x；\t//指针p是一个指向常量x的常量指针\n\n当使用类型别名时：\ntypedef int * ptr;\t\t\t//定义了一个int型指针的别名const ptr p = &amp;x;\t\t\t//p是指向int型的常量指针int * y = &amp;x;const ptr *p1 = &amp;y;\t\t\t//p1是一个普通指针，它的对象是指向int型的常量指针\n\n注意，不要将类型别名代回进行翻译以便理解，这样是错误的。例如：\n//原版const ptr p;\t\t\t\t//p是一个指向int型的常量指针//“翻译”版const int * p;\t\t\t\t//p是以一个指向const int型的普通指针（错）\n\n我们可以这样理解：使用类型别名后，无需再考虑是顶层const还是底层const，只需要将它当作新的基本变量即可（如int）。\n顶层const 和 底层const顶层const表示指针本身是一个常量，或者一个对象是一个常量。底层const表示指针所指的对象为一个常量。\n处理类型类型别名有两种方法定义类型别名\n\n使用关键字typedef\n使用别名声明\n\n//wages是double的同义词typedef double wages;using wages = double;\n\n\n\nauto类型说明符auto类型说明符可以让编译器代替我们去解析表达式的类型，需要注意的是，auto通过表达式的初始值来推测变量类型，并且会将表达式的值初始化给变量。所以，auto所定义的变量一定有初始值。\n使用auto也可以在一个语句中声明多个变量，因为一个语句只有一个基本数据类型，所以我们需要人为确定每个表达式的数据类型都一致，因此还是得自己判断。无法判断的话则可分多条语句写。\nauto i = 0, *P = &amp;i;\t\t//正确，可以将auto换成int来验证auto x = 1, y = 3.14;\t\t//错误，x和y的类型不一致\n\nauto与引用类型因为使用引用时，实际上是在使用引用的对象，所以真正参与auto初始化的是引用对象的值，因此，编译器会以引用对象的类型作为auto的类型。\nint i = 0, &amp;r = i;auto x = i;\t\t\t\t\t//x是int型变量auto y = r;\t\t\t\t\t//y是int型变量，r是i的别名，i本身是一个顶层const\n\nauto和顶层/底层const\n在定义基本数据类型时（此时不涉及底层const），auto会舍弃顶层const。因为保留顶层const毫无意义，定义一个等价的const变量，还不如直接使用原来的const变量。如果一定要保留顶层const，可以显式地指出。\n\nint const i = 0;int const *p1 =auto a = i;\t\t\t\t\t\t//a是int型const auto b = i;\t\t\t\t//i的推演类型为int，b是const int型\n\n\n而当定义复合类型时，auto会保留顶层以及底层const。\n定义一个类型为auto的引用时会保留表达式的顶层const（与定义基本数据类型不一样，此时保留顶层const是有意义的）；\n定义一个类型为auto的指针时会保留表达式的底层const；\n定义的指针是否需要顶层const可以显示的指出。\n\n\n\nint const i1 = 1;int i2 = 2;auto &amp;r1 = i1;\t\t\t\t//r1是一个int型常量的常量引用（保留顶层const）auto p1 = &amp;i1;\t\t\t\t//p1是一个指向int型常量的指针（保留底层const）p1 = &amp;i2;\t\t\t\t\t//正确，p1不是常量指针*p1 = 3;\t\t\t\t\t//错误，p1是一个指向int型常量的指针auto &amp;r2 = i2;\t\t\t\t//r2是一个int型变量的普通引用auto p2 = &amp;i2;\t\t\t\t//p2是一个指向int型变量的普通指针\n\ndecltype类型指示符const int ci = 0;int &amp;cj = ci;decltype(ci) x = 0;\t\t\t//x的类型为const intdecltype(cj) y = x;\t\t\t//y的类型是const int&amp;，绑定到xdecltype(cj) z；\t\t\t   //错误：z是一个引用，必须初始化\n\ndecltype和引用类型有三种方式可以得到引用类型\n\ndecltype（（））解引用带括号的变量\ndecltype（*p）解引用指针\ndecltype（引用变量）解引用一个引用变量\n\n与auto不同，decltype类型指示符只会使编译器解析并返回表达式的类型，而舍弃表达式的值。\ndecltype(f()) sum = x;\t\t//sum的类型就是函数f的返回类型\n\ndecltype和顶层/底层constdecltype与auto不同，当使用的表达式是一个变量时，decltype会返回该变量的类型（包括顶层const和引用）。\nauto和decltype的对比\n\n\n\nauto\ndecltype\n\n\n\n定义\n使用表达式的初始值初始化变量\n自定义值来初始化变量\n\n\n表达式为引用\n解析为引用所绑定的对象，需要引用得自行添加&amp;\n解析为引用\n\n\n定义基本数据类型\n不保留顶层const\n保留顶层const\n\n\n定义复合类型时\n保留顶层和顶层const\n保留顶层和底层const\n\n\n自定义数据结构C++11 新标准规定，可以为数据成员提供一个类内初始值。\n预处理器概述预处理变量不属于命名空间std，它由预处理器负责管理,因此可以直接使用预处理变量而无须在前面加上 std:: 。\nnullptr就是一个预处理变量，它的值为0。\n#define 指令把一个名字设为预处理变量。\n标准库类型命名空间using头文件中不应该使用using声明\n标准库类型string字符字面值和字符串字面值&#x27;c&#x27;\t\t//字符字面值&quot;Hello World!&quot;\t\t//字符串字面值\n\n其中，字符串字面值还包含一个’/0’，实际长度比内容多1。\n注意：C++中的字符串字面量并不是标准库函数中的string对象！！\n流状态输入运算符&lt;&lt;返回其左侧运算对象isteam，如std:cin。当我们使用一个istream对象作为条件时，其检测效果是检测流的状态。当遇到文件结束符或者无效输入时，istream对象的状态会变为无效。\n读写操作string在执行读写操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个字符开始读取，直到遇到下一个空白为止（注意：空白不读取）。\ngetline与string不同，getline会保留空格符，直到遇到换行符为止（注意换行符也被读取进来了，但是不会存入string对象中）。\nstring的empty和size操作empty函数返回值为布尔类型\nsize函数返回值为string::size_type类型，它是一个无符号类型的值，而且能够存放下任何string对象的大小。\n字面值和string对象相加当把 string对象 和 字符字面值 以及 字符串字面值 混在一条语句里时，必须确保每个加法运算符的两侧的运算对象至少有一个是string对象。\nstring s1 = &quot;hello&quot;, s2 = &quot;world&quot;;string s3 = s1 + &#x27;,&#x27; + s2 + &quot;!\\n&quot;;\n\n\n\n标准库类型vectorvector是一个类模板，我们需要使用尖括号来提供一些信息，来指定模板到底实例化成什么样的类。\nvector能容纳大多数类型的对象作为其元素，但是引用不是对象，所以不存在包含引用的vector。组成vector的元素甚至可以是vector，如vector&lt;vector&gt;,早期C++版本需在两个右尖括号中添加一个空格。\n要使用size_type，需指定它是由哪一种类型定义的。\nvector&lt;int&gt;::size_type\t\t\t//正确vector::size_type\t\t\t\t//错误\n\n迭代器获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员，如begin和end。其中，begin成员返回指向第一个元素的迭代器，end成员则返回指向容器尾元素的下一位置，即该容器本不存在的一个尾后元素，称作尾后迭代器（无实际含义，仅作为一个标记）。\n迭代器的使用和指针类似，我们能通过解引用迭代器来获取它所指示的元素。解引用一个非法迭代器或尾后迭代器都是未被定义的行为。\n迭代器类型拥有迭代器的标准库使用iterator和const_iterator来表示迭代器类型。如：\nvector&lt;int&gt;::iterator it1;string::iterator it2;vector&lt;int&gt;::const_iterator it3;string::iterator it4;\n\n两个迭代器距离的值是一个类型名为difference_type的带符号整型数。\n数组数组的定义与初始化编译时数组的维度应该时已知的，所以维度必须是一个常量表达式。\n使用字符串字面值初始化字符数组时，要注意末尾的空字符也会被拷贝进去。\n不能使用数组初始化或赋值另一个数组。\n理解复杂的数组声明理解复杂函数声明的含义，最好的办法就是从数组名字开始按照由内向外的顺序阅读，先左先右取决于运算符优先级。\nint *ptrs[10];//ptrs是一个大小为10的数组，数组的元素类型为指针int &amp;refs[10] = /* ? */;//错误，不存在引用的数组int (*Parray)[10] = &amp;arr;//Parray是一个指针，指向大小为10的int型数组，右边为该数组的地址int (&amp;arrRef)[10] = arr;//arrRef是一个引用，绑定了一个大小为10的int型数组arrint *(&amp;arry)[10] = ptrs;//arry是一个引用，指向了一个大小为10的int*型数组ptrs\n\n访问数组元素size_t数组下标是size_t类型的无符号数，足够表示内存中任意对象的大小，定义在头文件cstddef中。\nptrdiff_t两个指针相减的结果类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型，因为差值可能为负数，所以ptrdiff_t是一种带符号类型。\nauto、decltype与数组注意，使用数组做表达式时，auto返回指针类型，decltype返回一个同规模的数组类型。\nint ia[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;auto ia2(ia);\t\t//ia2是一个int型指针，指向ia第一个元素auto ia2(&amp;ia[0]);\t//等价于上面形式decltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;\t//使用decltype时，上述转变不会发生\n\n使用数组初始化vector对象虽然不允许使用数组初始化数组，也不允许使用vector初始化数组，但是数组可用来初始化vector对象。只需要指明数组的首元素地址和尾后地址即可。\nint array[3] = &#123;0,1,2&#125;;vector&lt;int&gt; ivec(begin(array),end(array));\n\n注：现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用c语言风格的基于数组的字符串。\n多维数组多维数组其实就是数组的数组\nint ia[3][4] = &#123;\t\t\t//三个元素，每个元素都是大小为4的数组    &#123;0,1,2,3&#125;,\t\t\t\t//各元素的初始值    &#123;4,5,6,7&#125;,    &#123;8,9,10,11&#125;&#125;;\n\n使用范围for语句处理多维数组如果要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。\n//将元素的值设为该元素在整个数组中的序号size_t cnt = 0;for(auto &amp;row : ia)&#123;\tfor(auto &amp;col : row)&#123;        col = cnt;        ++cnt;    &#125;&#125;\n\n因为如果不使用引用，编译器会自动将数组形式的元素解析为指向第一个元素的指针，在下一个循环时，编译器就会试图在一个指针内循环。并且，如果最后一层需要用来修改元素的值，则也需要使用引用类型，否则会得到数组元素的基本数据类型如int。\n表达式sizeof运算符\n对数组执行sizeof运算会得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将结果求和。注意，sizeof不会将数组转换成指针来处理。\n对string对象或vector对象执行sizeof运算只会返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。string的实现在各个库中可能有所不同，但是在同一个库中相同的一点是,无论string中存放多长的字符串，其sizeof()都是固定的,字符串所占空间是从堆中动态分配的，与sizeof()无关。\n\n显示转换命名的强制类型转换具有如下形式：\ncast-name&lt;type&gt;(expression);\n\ntype为目标类型，expression是要转换的值，cast-name是static_cast, dynamic_cast, const_cast, reinterpret_cast中的一种，cast-name指定了执行的是哪一种转换。\nconst-castconst-cast中的type类型必须是指针，引用 或者 指向对象类型成员的指针。\nconst能去除运算对象的底层const，同时也能给运算对象增加底层const。\n//去除底层constint a = 0;const int&amp; i = a;i = 1;\t\t\t\t//错误，i为const int&amp;型，不可修改int&amp; j = const_cast&lt;int&amp;&gt;(i);j = 1;\t\t\t\t//正确，j为int&amp;型，可修改//此时a = 1, i = 1, j = 1\n\n\n\n语句switch内部的控制流如果某个case标签匹配成功，将从该标签开始往后顺序执行所有的case分支，以及default标签。\n范围for语句范围for的语法格式为：\nfor(declaration : expression)&#123;    statement;&#125;\n\nexpression是一个序列，比如用花括号括起来的初始值列表、数组、vector或者string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。\ndeclaration定义一个变量，序列中的每一个元素都得能转换成该变量的类型。确保类型相容的最简单的方法是使用auto类型说明符。\n范围for语句的定义来源于与之等价的传统for语句：\nfor(auto begin = v.begin(),end = v.end();begin != end; ++begin)&#123;    statement;&#125;\n\n通过观察其原理，我们不难理解为什么不能通过范围for语句增删vector对象（以及其他类型）的元素了。在范围for语句中，预存了end() 的值。一旦在序列中添加（删除）元素，end函数的值可能就变得无效了。\ndo while语句do    statement；while(condition);\n\n注意，condition使用的变量必须定义在循环体之外。\ntry语句块和异常处理throw表达式if(A!=B)throw runtime_error(&quot;A and B is not the same!&quot;);\n\nthrow表达式抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。必须初始化runtime_error的对象，方式是给它提供一个string对象或者一个C风格的字符串，这个字符串中有一些关于异常的辅助信息。\ntry语句块try语句块的通用语法形式是\ntry&#123;    //程序要执行的代码    statement;\t\t//其中包括throw表达式&#125;catch (exception-declaration)&#123;\t//处理异常的代码    handler-statements;&#125;catch (exception-declaration)&#123;    handler-statement;&#125;\n\n如果程序要执行的某段代码可能会抛出一个runtime_error类型的异常，我们可以将这段代码放在try语句块中。\n函数在寻找处理代码的过程中退出一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能又调用了包含另一个try语句块的新函数。寻找处理代码的过程与函数调用过链正好相反。当异常被抛出时，首先搜索抛出该异常的函数，如果没有找到匹配的catch子句，则终止该函数，退回调用该函数的函数中继续寻找，以此类推，直至找到适当类型的catch子句为止。\n如果最终还是没能找到任何匹配的catch子句，程序将转到一个名为terminate的标准库函数，该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。\n函数局部静态对象某些时候，有必要令局部变量的生命周期贯穿函数调用以及之后的时间，此时我们可以将局部变量定义成static类型从而获得这样的对象，即局部静态对象。\nstatic int a = 1；\n\n参数传递当形参是引用类型时，我们说它对应的实参被引用传递(passed by reference)，或者函数被传引用调用(called by reference)；当实参的值被拷贝给形参时，形参和实参是两个独立的对象。我们说这个实参被值传递(passed by value),或者函数被**传值调用(called by value)**。\n传引用参数void reset(int &amp;i)&#123;\ti = 0;&#125;\n\n调用该函数时，i会绑定我们传给函数的int型对象**(注意我们应直接传入对象，而非对象地址或者对象的引用)**。\nint j = 1;reset(j);\t\t//直接传入int型对象，j的值被改为0\n\nconst 形参和实参和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。\nconst int ci = 1;int i = ci;\t\t\t //拷贝ci时忽略其顶层consti = 3;\t\t\t\t//正确\n\n当形参有顶层const时，传给它常量对象或非常量对象都是可以的。\nvoid fcn(const int i);\t\t//fcn可以读取i，但是不能修改ivoid fcn(int i);\t\t\t//错误，重复定义fcn(int)\n\n当函数不需要修改形参时，应该将该形参定义成const型。\n数组形参已知数组有两个特殊的性质：\n\n不允许拷贝数组\n使用数组时通常会将其转化成指针\n\n所以当向函数内传递一个数组时，实际上传递的是指向数组首元素的指针。尽管不能以值的方式传递数组，但是可以将形参写成类似数组的形式：\nvoid print(const int*);void print(const int[]);void print(const int[10]);\t//此处维度只是表明调用函数所期望的数组大小，实际大小不一定如此\n\n尽管表现形式不同，但是三个函数是等价的，每一个函数的唯一形参都是const int*类型。\n和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。调用者应尽量告诉函数数组的大小，具体方式有：\n\n使用标准库规范，向函数传递指向数组首元素和尾后元素的指针：\nvoid print(const int *beg, const int *end)&#123;\twhile(beg != end)&#123;\t\tcout &lt;&lt; *beg++ &lt;&lt; endl;\t//输出当前元素并将指针向前移动一位    &#125;&#125;\n显示传递一个表示数组大小的形参：\nvoid print(const int ia[], size_t size)&#123;    for(size_t i = 0; i != size; ++i)&#123;        cout &lt;&lt; ia[i] &lt;&lt; endl;\t\t//使用ia[i]输出当前元素    &#125;&#125;\n\n数组引用形参\nvoid print(int (&amp;arr)[10])&#123;\tfor(auto elem : arr)&#123;        cout &lt;&lt; elem &lt;&lt; endl;    &#125;&#125;\n\n注意：\n\n根据运算符优先级可知，&amp;arr两边的括号不能少。\n该写法限制了print函数的可用性，函数只能接受大小为10的数组。\n\n返回类型和return语句无返回值函数没有返回值的return语句只能用在返回类型位void的函数中。返回void的函数不一定要有return语句，因为此类函数末尾会隐式地执行return。如果想在函数中间位置退出，可以使用return语句，类似于break语句。\n有返回值函数该函数内的每条return语句都必须返回一个与函数返回类型相同，或者能隐式转换成函数返回类型的值。\n不要返回局部对象的引用或指针当函数结束时，临时对象占用的空间都将被释放，此时局部对象的引用和指针都指向了不再有效的内存空间。\n返回类类型的函数和调用运算符如果函数返回指针、引用或者类的对象，我们就可以使用函数调用的结果访问结果对象的成员。\n//\tshortString函数返回两个string对象中较短的一个auto sz = shortString(s1,s2).size();\n\n引用返回左值函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数将得到左值，其他返回类型得到右值。\n特别的，我们能为返回类型是非常量引用的函数的结果赋值：\nchar &amp; get_val(string &amp;str, string::size_type ix)&#123;    return str[ix];&#125;string s(&quot;a value&quot;);get_val(s,0) = &#x27;A&#x27;;\t\t//将s[0]的值改为了A\n\n列表初始化返回值C++11新标准规定，函数可以返回花括号包围的值的列表。\nvector&lt;string&gt; process()&#123;    //..    if(statement)return &#123;&#125;;\t\t\t//返回一个空vector对象    else return &#123;&quot;result is&quot;, s1, s2&#125;;\t//返回列表初始化的vector对象&#125;\n\n返回数组指针因为数组不能被拷贝，所以函数不能返回数组。可以通过以下方式返回数组指针：\n使用类型别名typedef int arrT[10];\t//arrT是一个类型别名，表示含有10个整数的数组using arrT = int[10];\t//与上一语句等价arrT* func(int i);\t\t//func返回一个指向含有10个整数的数组的指针\n\n声明一个返回数组指针的函数返回数组指针的函数形式如下：\n//Type (*function(parameter_list)) [dimention]int (*func(int i))[10];\t\n\n同理解数组的复杂声明一样，先找到函数名，由内向外解释，左右顺序取决于两边各自优先级，例：\n\nfunc(int i)：表示调用func函数需要一个int型实参\n(func(int i))：表示我们可以对函数调用的结果执行解引用操作，即函数返回指针类型。*该括号不能省略，因为下标 [ ] 的优先级大于解引用 * 的优先级。\n(*func(int i)) [10]：表示解引用后将得到一个大小为10的数组\nint (*func(int i)) [10]：表示数组中的元素为int类型\n\n使用尾置返回类型C++11新标准规定任何函数都可以使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，所以常用于声明一个返回数组指针的函数。\nauto func(int i) -&gt; int(*)[10];\n\n将函数真正的返回类型写在形参列表之后，在本该出现返回类型的地方放置一个auto。（即上一种方式中，将函数名称抽离出，置前）\n使用decltype如果我们知道返回的指针将指向哪一个数组，就可以使用decltype关键字声明返回类型。\nint arr[] = &#123;1,2,3,4,5&#125;;decltype(arr) * arrPtr(int i)&#123;    //..    return &amp;arr;&#125;\n\n注意不要忘记在decltype后增加一个 * 符号。\n函数重载重载与作用域如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。\n在不同的作用域中无法重载函数名。\n内敛函数在主调函数调用函数时，先将现场压入栈以保存现场 - 转去执行被掉函数 - 返回主调函数、现场出栈以恢复现场 - 继续往下执行。\n为了减少函数调用的成本，特别是对于小型函数，C++提供了内敛函数（inline）。C++规定：若要在程序中应用内敛函数，需要在首次出现函数名称时，在相应的函数定义或函数声明中的函数类型前面加上限定符inline\n好处：在编译时，将在所有调用内敛函数的语句处插入函数体代码，从而节约了函数调用的系统开销，提高了程序的执行效率。由于内敛函数的代码会在任何调用它的地方展开，所以对内敛函数的调用会增加程序的长度。如果函数太复杂，代码膨胀带来的坏处会大于效率的提高带来的好处。因此inline往往与频繁使用的小函数一起使用。\n注意\n\n递归函数不能定义为内敛函数。另外，内敛函数的函数体内也不允许出现循环语句（for，while，do-while）和开关语句（switch）。遇到这种情况，即使加上inline，也只能按照非内敛函数使用。\n类内定义的函数，编译器会优先将其编译成内联函数，对于复杂的成员函数则编译成普通函数。\n\n函数指针函数指针指向函数而非对象。函数指针的类型由函数的返回类型和形参类型共同绝决定，与函数名无关。\n函数指针的定义：\n//声明一个比较两个string对象长度的函数bool lengthCompare(const string&amp;, const string&amp;);\t//未初始化//声明一个指向该函数的指针bool (*ptr)(const string&amp;, const string&amp;);\t//未初始化\n\n函数指针的初始化:\nptr = lengthCompare;\t//初始化，ptr指向名为lengthCompare的函数ptr = &amp;lengthCompare;\t//等价的赋值语句，取地址符是可选的\n\n相应的，我们也可以直接使用指向函数的指针调用函数，而不提前解引用指针。\nbool b1 = ptr(&quot;hello&quot;,&quot;goodbye&quot;);bool b2 = (*ptr)(&quot;hello&quot;,&quot;goodbye&quot;);bool b3 = lengthCompare(&quot;hello&quot;,&quot;goodbye&quot;);\n\n函数指针形参和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。\n//直接使用函数类型作为形参，它会自动转换成指向该函数的指针void fcn(const string&amp;, bool lengthCompare(const string&amp;, const string&amp;))//也可以显式地将形参定义为指向函数的指针void fcn(const string&amp;, bool (*ptr)(const string&amp;, const string&amp;))\n\n我们也可以直接把函数作为实参来使用，此时它也会自动转换成指向该函数的指针\nfcn(s1, lengthCompare);\n\n直接使用函数指针类型显得冗长繁琐，类型别名 和 decltype 可以将函数指针的使用简化\n//fcn 和fcn1 是函数类型typedef bool fcn(const string&amp;, const string&amp;);typedef decltype(lengthCompare) fcn1;\t//等价语句//fcnp 和fcnp1 是函数指针typedef bool (*fcnp)(const string&amp;, const string&amp;);typedef decltype(lengthCompare) *fcnp1;\t//等价语句\n\n返回函数指针使用类型别名基本同数组：\nusing F = bool(const string&amp;, const string&amp;);using FP = bool(*)(const string&amp;, const string&amp;);PF fcn1(int);\t//正确，fcn1接受一个int型的形参，返回指向函数的指针F fcn2(int);\t//错误，fcn2不能返回一个函数F *fcn3(int);\t//正确，显式指定返回类型为指向函数的指针\n\n也可以直接声明:\nbool (*fcn4(int))(const string&amp;, const string&amp;);\n\n按照由内向外的顺序阅读:\n\nfcn4(int)：表示fcn4是一个接收int型值的函数\n(*fcn4(int))：表示fcn4返回一个指针\n(*fcn4(int))(const string&amp;, const string&amp;)：指针类型包括形参列表，表示此指针指向函数\nbool (*fcn4(int))(const string&amp;, const string&amp;)：表示该函数指针所指的函数返回值为bool\n\n使用尾置返回类型auto fcn5(int) -&gt; bool (*)(const string&amp;, const string&amp;);\n\n使用decltypedecltype(lengthCompare) *fcn6(int);\n\n类\n成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。\n作为接口组成部分的非成员函数，它们的定义和声明都在类的外部。\n\n定义抽象的数据类型this指针我们调用成员函数时，实际上是在代替某个对象调用它。成员函数内指向类其他成员时，实际上是在隐式地指向调用该函数的对象的成员。为了实现这一点，成员函数实际上在使用一个名为this的额外的隐式形参来访问调用它的对象。当我们调用某个成员函数时，将使用调用该函数的对象的地址来初始化该函数的this形参。\n//使用Sales_data类的对象total调用成员函数isbntotal.isbn();//伪代码，相当于执行了以下过程Sales_data::isbn(&amp;total)\n\n在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需使用成员访问符来实现，正是因为this所指的就是该对象，任何对类成员的直接访问都会被看作this的隐式引用。也就是说，当isbn使用了bookNo时，它隐式的使用了this所指的对象的成员bookNo，就像我们写了this-&gt;bookNo一样。\n因为this是隐式定义的，所以任何自定义为this的参数或变量都是非法行为。\n因为this始终指向调用成员的对象，所以this是一个常量指针，修改this中保存的地址是非法行为。\nconst成员函数默认情况下，在类的成员函数中，this指向的是类类型非常量版本的常量指针，这就意味着我们不能把this绑定到一个常量对象上。这一情况使得我们不能在一个常量对象上调用普通的成员函数，此时我们就需要将成员函数声明为常量成员函数。\nstd::string isbn() const;\n\n在参数列表后加上const关键字，可以修改隐式this指针的类型。\n类作用域和成员函数：成员函数体可以随意使用类中的其他成员而无需在意这些成员定义出现的先后顺序，因为编译器分两步处理类：首先编译成员的声明，然后才编译成员函数体。\n在类的外部定义成员函数在类的外部定义成员函数时，返回类型，形参列表和函数名都需要和类内部的声明一致，如果成员被声明为常量成员函数，那其定义也必须在形参列表后明确指定const属性。同时，类外部定义的成员函数的名字必须包含它所属的类名。\ndouble Sales_date::avg_price() const&#123;    //...    return 0;&#125;\n\n定义一个返回this对象的函数Sales_data&amp; Sales_data::combine(const Sales_date &amp;rhs)&#123;    //..    return *this;&#125;\n\n因为函数调用为左值，所以需要返回引用类型；所以通过解引用this指针来返回调用该函数的对象。\n定义类相关的非成员函数尽管类的辅助函数定义的操作从概念上来看属于类的接口的组成部分，但是它们实际上不属于类。所以非成员函数的方式与定义其他函数一样，但是它一般应与类声明在同一个头文件中。在这种方式下，使用接口的任何一部分都只需要引入一个文件。\n构造函数\n构造函数的名字与类名相同。\n和其他函数不同的是，构造函数没有返回类型。\n一个类可以包含多个构造函数，同重载函数，不同的构造函数必须在形参数量或类型上有所区别。\n构造函数不能被声明成const型的，因为构造过程需要向对象写值。\n\n默认构造函数如果我们的类没有显式的定义构造函数，那么编译器会为我们隐式的定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数。\n默认构造函数初始化对象成员的规则：\n\n如果存在类内初始值，使用该值初始化成员\n否则默认初始化成员\n\n某些类不能依赖于合成的默认构造函数对于一个普通的类来说，必须定义它自己的默认构造函数，有因有三：\n\n编译器只有在我们没有为类编写任何构造函数的情况下才会生成一个默认构造函数。一旦我们定义了其他的构造函数，那么除非我们再定义一个默认构造函数，否则类是没有默认构造函数的。因此，当定义了其他构造函数时，也必须在定义一个默认构造函数。\n使用了定义在块中的内置类型（定义在函数体内部的内置类型）或者复合类型（比如数组和指针等）的类在默认初始化时，它们的值将会是未定义的。此时我们需要在类内部初始化这些成员，或者定义一个自己的默认构造函数。\n如果类中包括了一个其他类类型的成员，并且这个成员的类型没有默认构造函数，那么该成员将无法被初始化。\n\n定义构造函数struct Sales_data&#123;    //默认构造函数\tSales_data() = default;    //含有初始值的构造函数    Sales_data(const std::string &amp;s, unsigned n): bookNo(s), units_solds(n) &#123;&#125;;    //冒号，以及冒号至花括号之间的部分为 构造函数初始值列表        //以下是类的成员    //...&#125;//在类的外部定义构造函数,必须指明该构造函数属于哪一个类的成员Sales_data::Sales_data(std::istream &amp;is)&#123;    read(is, *this);\t//读取一条信息存入this所指对象中&#125;\n\n访问控制与封装C++使用访问说明符加强类的封装性：\n\n定义在public说明符后的成员在整个程序内可被访问，public成员定义类的接口\n定义在private说明符后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节\n\nclass Sales_data&#123;public:    Sales_data() = default;    Sales_data(const std::string &amp;s, unsigned n): bookNo(s), units_solds(n) &#123;&#125;;private:    double revenue = 0.0;    std::string bookNo;&#125;\n\n使用class或struct关键字：\n使用class或struct定义的唯一区别就是默认的访问控制权。\n\nstruct：定义在第一个访问控制符之前的成员都是public的。\nclass:定义在第一个访问控制符之前的成员都是private的。\n\n友元因为类的接口函数不属于类的成员，所以无法访问类的非公有成员。此时可以通过在类的声明内添加以关键字friend开始的函数声明语句，使得该函数成为该类的友元，获取访问非公有成员的权限。\nclass Sale_data &#123;friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;);    public:    //...private:    //...&#125;\n\n类之间的友元关系如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。\nclass one&#123;    //..&#125;class two&#123;    friend class one;    //class one 的剩余部分&#125;\n\n需要注意的是，友元关系是单向的。\n构造函数再探//example one:tempClass::tempClass(int i, int j): num1(i), num2(j)&#123;&#125;//example two:tempClass::tempClass(int i, int j)&#123;\tnum1 = i;\tnum2 = j;&#125;\n\n两种方式的效果是相同的但是，example one的版本是初始化了成员，example two的版本是对成员进行了赋值操作。\n这一区别到底会有什么深层次的影响完全依赖于数据成员的类型。\n构造函数初始值列表有时必不可少大部分时间我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const 或引用的话，则必须将其初始化。类似的，若成员属于某个类型并且该类型没有定义默认构造函数时，也必须将这个成员初始化。\nclass tempClass&#123;public:    tempClass(int i);private:    int a;    const int b;    int&amp; c;&#125;tempClass::tempClass(int i)&#123;\ta = i;\t\t//正确    b = i;\t\t//错误，不能给const赋值    c = a;\t\t//错误，c未初始化&#125;\n\n因为我们没有给成员a， b提供构造函数初始值，程序将会报错。\n应改为：\nclass tempClass&#123;public:    tempClass(int i);private:    int a;    const int b;    int&amp; c;&#125;tempClass::tempClass(int i): a(i), b(i), c(a)&#123;    &#125;\n\n成员初始化的顺序构造函数初始化值列表中成员出现的顺序并不决定初始化的顺序，成员的初始化顺序取决于它们在类定义中出现的顺序。\nclass tempClass&#123;    int x;    int y;public:    //将报错，因为先初始化x，而此时y还未初始化    tempClass(int i): y(i), x(y)&#123;&#125;&#125;\n\n因此，如果可以的话，尽量使用构造函数初始化列表内的值初始化成员，而尽量避免使用同一个对象中的其他成员。\n这样的好处在于我们无需考虑成员的定义顺序。\n默认实参和构造函数如果一个构造函数为所有参数都提供了默认实参，那么它实际上也定义了默认构造函数\n委托构造函数一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）工作委托给了其他构造函数。\n和其他构造函数一样，一个委托构造函数也只有一个成员初始值的列表和一个函数体。\nclass temp_class&#123;public:    temp_class(int a, int b, int c):x(a), y(b), z(c)&#123;&#125;    //委托构造函数    temp_class(int a):temp_class(a,0,0)&#123;&#125;    temp_class(int a, int b):temp_class(a, b, 0)&#123;&#125;private:    int x, y, z;&#125;\n\n隐式的类类型转换在Sale_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sale_data隐式转换的规则。\n也就是说，在需要使用Sale_data的地方，我们可以使用string和istream作为代替。\n只允许一步类类型转化\n把“9-999-99999-9”转换为string型\n再把这个临时的string转换成Sale_data\n\n由于隐式的使用了两种转换规则，所以它是错误的\n为了完成上述调用，我们可以显式的将字符串转换为string类型或者Sale_data对象。\n抑制构造函数定义的隐式转换类类型转换并不总有效，在要求隐式转换的程序上下文，我们可以通过将构造函数声明为 explicit 加以阻止。\n注意\n\n需要多个实参的构造函数不能执行隐式转换，所以无需将这些构造函数指定为explicit的\n只能在类内部声明构造函数时使用explicit关键字，在类外定义时不应使用\n\nexplicit构造函数只能用于直接初始化发生隐式转换的一种情况是我们是执行拷贝形式的初始化。\n#include &lt;iostream&gt;using namespace std;class temp_class_one &#123;public:\ttemp_class_one(int i) :x(i) &#123;&#125;\tint x;&#125;;class temp_class_two &#123;public:\texplicit temp_class_two(int i) :x(i) &#123;&#125;\tint x;&#125;;int main() &#123;\t//直接初始化\ttemp_class_one temp1(1);\tcout &lt;&lt; temp1.x &lt;&lt; endl;\t//输出1\t//拷贝形式的初始化\ttemp_class_one temp2 = 2;\tcout &lt;&lt; temp2.x;\t//输出2    \ttemp_class_two temp3 = 3;\t//报错：不存在从 &quot;int&quot; 转换到 &quot;temp_class_two&quot; 的适当构造函数\treturn 0;&#125;\n\n—更新于2021.11.18—\n","categories":["tutorial"],"tags":["C++"]},{"title":"基于QT的学生信息管理系统","url":"/StuInfoManageSys.html","content":"基于Qt开发，数据库为SQLite。\n\n\n项目已开源，点击此处查看\n测试账号教师端\n\n\n用户名\n密码\n\n\n\nadmin\n555\n\n\n老师A\n123\n\n\n学生端\n\n\n用户名\n密码\n\n\n\n学生1\n111\n\n\n学生2\n222\n\n\n学生3\n333\n\n\n学生4\n444\n\n\n学生5\n555\n\n\n学生6\n666\n\n\n学生7\n777\n\n\n学生8\n888\n\n\n学生9\n999\n\n\n程序功能登录端\n\n\n用户密码输入为空检测\nenter快捷键登录\n右下角关于文档  获取帮助\n\n学生端\n\n所有课程成绩查询\n成绩降序/升序排列\n窗口自适应大小\n\n教师端主面板\n\n\n窗口自适应大小\n支持新增多班级的同名课程\n双击列表默认打开课程管理面板，新增课程名为空检测，课程选择检测\n删除课程\n\n管理面板\n\n\n班级成绩排名升序/降序排列\n窗口自适应大小\n班级成绩分析：及格/优秀 人数、比率；最高分、最低分 的分值、学生名单；平均分\n成绩分布图\n修改学生成绩，成绩区间0-100，可使用方向键快捷更改\n删除学生\n\n新增学生面板\n\n窗口大小自适应\n批量增加学生\nenter快捷键增加\n学生姓名、成绩输入为空检测\n\n项目框架程序界面关系\n工程管理文件 &lt;配置项&gt;StuInfo_Manage_System.pro项目所用模块：\nQT += core gui sql charts\n\n项目所用头文件：\nHEADERS += \\    addstudent_window.h \\    global.h \\    mainwindow.h \\    manage_window.h \\    student_window.h \\    teacher_window.h\n\n项目所用源文件：\nSOURCES += \\    addstudent_window.cpp \\    global.cpp \\    main.cpp \\    mainwindow.cpp \\    manage_window.cpp \\    student_window.cpp \\    teacher_window.cpp\n\n项目所用ui文件：\nFORMS += \\    addstudent_window.ui \\    mainwindow.ui \\    manage_window.ui \\    student_window.ui \\    teacher_window.ui\n\n项目所用资源文件\nRESOURCES += \\    setIcon.qrc\n\n\n\n具体结构类global数据成员static QSqlDatabase db;\t\t\t//实例化一个数据库连接\n\n函数成员void Global::ins_db();\t\t\t//用于初始化数据库的连接static QSqlDatabase getdb();\t//其他类获取数据库连接db的接口\n\n\n\nmainwindow数据成员Teacher_Window *w1;\t\t\t\t//储存教师窗口实例化对象Student_Window *w2;\t\t\t\t//储存学生窗口实例化对象QString Username_this;\t\t\t//记录输入用户名QString Password_this;\t\t\t//记录输入密码\n\n槽：void Login_Button_clicked();\t//响应登录按钮void Signup_Button_clicked();\t//响应注册按钮void Reset_Button_clicked();\t//响应重置按钮void Input_Judge();\t\t\t   //判断输入是否为空\n\n\n\nteacher_window数据成员：QWidget* top;\t\t\t\t\t//记录调用自己的parent对象QString classid_selected = &quot;&quot;;\t //记录选中的课程IDQString class_selected = &quot;&quot;;\t //记录选中的课程名\n\n函数成员：void reload_ClassList();\t//刷新课程名单void setupClassList();\t\t//初始化课程名单\n\n槽：void getItem(int row, int column);\t\t//获取所选表格位置void Select_Judge();\t\t//判断是否选择课程，并选择调用管理按钮、删除按钮以及新增按钮void manage_button_clicked();\t\t\t//响应管理按钮void delete_button_clicked();\t\t\t//响应删除按钮void add_button_clicked();\t\t\t\t//响应新增按钮void exit_button_clicked();\t\t\t\t//返回至上一界面\n\n\n\nmanage_window数据成员：QWidget* top;\t\t\t\t//记录调用自己的parent对象int distribution[10];\t\t//记录班级成绩分布值QString student_selected;\t//记录选中的学生QString classid_this;\t\t//记录选中的课程QString classname_this;\t\t//记录选中的课程idint grade;\t\t\t\t\t//记录从数据库返回的成绩int highest_score;\t\t\t//记录班级最高成绩int lowest_score;\t\t\t//记录班级最低成绩float average_score;\t\t//记录班级平均成绩int total;\t\t\t\t\t//记录班级总人数int pass_num;\t\t\t\t//记录班级及格人数int above_num;\t\t\t\t//记录班级优秀人数QString highest_stu = &quot;-&quot;;\t //记录最高分学生名单QString lowest_stu = &quot;-&quot;;\t//记录最低分学生名单bool order_mode = true;\t\t//记录成绩排序模式AddStudent_window* w1;\t\t//储存新增学生面板实例化对象QChartView *chartView;\t\t//储存新增图表视图实例化对象QChart *chart;\t\t\t\t//储存新增图标实例化对象QValueAxis *axisY;\t\t\t//储存Y轴实例化对象\n\n函数成员：void setupList();\t\t\t//初始化StudentListvoid reload_analysis();\t\t//重新加载分析图表void CreateChart();\t\t\t//创建成绩分布图\n\n信号：此处定义一个信号供setupList()使用\n不直接在setupList()中调用该函数，是因为reload_StudentList()中会通过sender()来获取发射信号来调用自己的对象名，以实现成绩升序、降序排列（注意，reload_StudentList()是槽函数），如果直接在setupList()中调用reload_StudentList()，sender()会报错。\nvoid init();\t\t//用于调用reload_StudentList(); \n\n槽：void exit_button_clicked();\t\t\t\t//返回至上一界面void reset_button_clicked();\t\t\t//响应修改成绩按钮void reload_StudentList();\t\t\t\t//重新加载StudentListvoid reloadChart();\t\t\t\t\t\t//重新加载成绩分布图void getItem(int row, int column);\t\t //获取所选表格位置void delete_button_clicked();\t\t\t//响应删除按钮void add_button_clicked();\t\t\t\t//响应新增学生按钮void Select_Judge();\t\t\t\t\t//判断是否选择学生\n\n\n\naddstudent_window数据成员：QWidget* top;\t\t\t\t//记录调用自己的parent对象int addlist_rows = 0;\t\t//记录新增学生个数\n\n信号：void reloadStudentList_signal();\t//重新加载manage_window中StudentList的信号void reloadChart_signal();\t\t\t//重新加载manage_window中成绩分布图的信号\n\n槽：void add_student();\t\t\t//响应增加按钮void backTotop();\t\t\t//返回至上一界面\n\n\n\nstudent_window数据成员：QWidget* top;\t\t\t\t//记录调用自己的parent对象\n\n函数成员：void setup_ClassList();\t\t//初始化学生成绩表\n\n信号：void init();\t//同manage_window，用于避免sender()报错的同时调用load_ClassList()\n\n槽：void load_ClassList();\t\t\t//重新加载学生成绩表void exit_button_clicked();\t\t//返回至上一界面\n\n\n\n具体实现建议直接读相关函数的具体实现代码,需注意部分已注释，此处不在赘述。\n","categories":["projects"],"tags":["C++","Qt"]},{"title":"基于Vivado的32位无符号数排序模块","url":"/sortingmodule.html","content":"使用Verilog语言设计一个对16个32位无符号数进行排序的模块。\n\n\n项目已开源，点击此处查看\n项目简述项目环境与描述方式设计语言： Verilog硬件描述语言开发环境： Vivado 2019.2测试环境： LS-CPU-EXB-002实验箱，搭载Xilinx Artix-7 xc7a200tfbg676-2描述方式： 结构化描述方式\n设计目标采用Verilog语言描述一个对16个32位无符号数排序的运算电路。\n实现情况采用双调排序算法，不同模块间并行计算的策略，实现了对输入的16个32位无序无符号数进行排序，并按升序输出的功能。\n此电路在Vivado和本地FPGA开发板上均调试运行成功。\n实现细节算法思想双调序列（Bitonic Sequence）是指由一个非严格增序列X和非严格减序列Y（其中X的最小元素正好是Y的最大元素）构成的序列。\n定义: 一个序列a1,a2,…,an是双调序列（Bitonic Sequence），如果:\n1.存在一个ak(1≤k≤n),使得a1≥…≥ak≤…≤an成立；或者\n2.序列能够循环移位满足条件（1）\n简单来说，双调序列是一个先单调递增后单调递减（或者先单调递减后单调递增）的序列。\n而双调的归并网络是基于Batcher定理而构建的。\nBatcher定理是说将任意一个长为2n的双调序列A分为等长的两半X和Y，将X中的元素与Y中的元素一一按原序比较，即 a[i]与 a [i + n]( i ≤ n )比较，将较大者放入MAX序列，较小者放入MIN序列。则得到的MAX和MIN序列仍然是双调序列，并且MAX序列中的任意一个元素不小于MIN序列中的任意一个元素。再分别对得到的所有MAX和MIN序列进行上述的重复操作，不断缩小序列的规模，直至所有MAX和MIN序列的规模数为2。对于最后得到的每个小序列b[i]而言，满足max(b[i])&lt;=min(b[i+1])，从而实现了整体序列内部元素的有序排列。\n因此，对于16个元素，我们可以使用以下步骤实现升序排序：\n\n相邻两个元素，两两之间进行比较，合并形成8个单调性相反的单调序列；\n对8个单调序列，两两合并，形成4个双调序列，分别按相反单调性排序，得到4个单调性相反的双调序列；\n对4个长度为4的相反单调性单调序列，相邻之间合并，生成两个长度为8的双调序列，分别按相反单调性排序；\n对2个长度为8的相反单调性单调序列，相邻之间合并，生成1个长度为16的双调序列，升序排序。\n\n示意图\n\n明细表模块明细表\n\n\n模块名\n模块输入\n模块输出\n描述\n\n\n\nTestInboard\n*\n*\n实验箱调试使用\n\n\nSorting_16\n16个32位数（乱序）\n16个32位数（升序）\n顶层模块，调用多个子模块以进行排序\n\n\nBitonic_Sequence_4\n16个32位数（乱序）\n4组长度为4的双调序列\n将16个数分为4组长度为4的双调序列供后续模块使用\n\n\nBitonic_Sequence_8\n4组长度为4的双调序列\n2组长度为8的双调序列\n将4组长度为4的双调序列分为2组长度为8的双调序列供后续模块使用\n\n\nBitonic_Sequence_16\n2组长度为8的双调序列\n1组长度为16的双调序列\n将2组长度为8的双调序列分为1组长度为16的双调序列供后续模块使用\n\n\nascendingSort_4\n1组长度为4的双调序列\n4个32位数（升序）\n将长度为4的双调序列转换为升序序列\n\n\nascendingSort_8\n1组长度为8的双调序列\n8个32位数（升序）\n将长度为8的双调序列转换为升序序列\n\n\nascendingSort_16\n1组长度为16的双调序列\n16个32位数（升序）\n将长度为16的双调序列转换为升序序列\n\n\nSwap\n2个长度为32的数\n按大小将两数输出\n2个32位数的大小比较模块\n\n\nComparator_2bit\n2个2位数\n三种大小比较结果（大于、等于、小于）\n2个2位数的大小比较模块\n\n\nComparator_4bit\n2个4位数\n三种大小比较结果（大于、等于、小于）\n2个4位数的大小比较模块\n\n\nComparator_16bit\n2个16位数\n三种大小比较结果（大于、等于、小于）\n2个16位数的大小比较模块\n\n\nComparator_32bit\n2个32位数\n三种大小比较结果（大于、等于、小于\n2个32位数的大小比较模块\n\n\nAnd_32bit\n1个32位数,1个1位数\n1个32位数\n根据一位使能信号决定32位数输出与否\n\n\nOr_3_32bit\n3个32位数\n1个32位数\n将三种比较结果中使能信号为真的数据输出\n\n\n文件明细表\n\n\n文件名\n包含模块\n描述\n\n\n\nSorting_Lcd_Module.v\nSorting_16,  lcd_module\n含lcd的顶层模块\n\n\nSwap_Module.v\nSwap\n数据交换\n\n\nSorting_Module.v\nSorting_16\n排序顶层模块\n\n\nLogic_Module.v\nAnd_32bit,  Or_3_32bit\n逻辑门模块，供最终输出使用\n\n\nComparator_Module.v\nComparator_2bit,  Comparator_4bit,  Comparator_16bit,  Comparator_32bit\n数据大小比较模块\n\n\nBitonic_Sequence_Module.v\nBitonic_Sequence_4,  Bitonic_Sequence_8,  Bitonic_Sequence_16\n双调序列生成模块\n\n\nascendingSort_Module.v\nascendingSort_4,  ascendingSort_8,  ascendingSort_16\n升序序列生成模块\n\n\nlcd_module.dcp\n实验资料自带\nlcd模块\n\n\n上板测试结果\n\n","categories":["projects"],"tags":["Vivado","Verilog"]},{"title":"基于Vivado的32位ALU设计","url":"/32bitALU.html","content":"使用Verilog语言结构化描述方式设计一个32位ALU，具有32位无符号数加法、逻辑运算、移位、截断等功能。\n\n\n项目已开源，点击此处查看\n项目简述项目环境与描述方式设计语言： Verilog硬件描述语言开发环境： Vivado 2019.2测试环境： LS-CPU-EXB-002实验箱，搭载Xilinx Artix-7 xc7a200tfbg676-2描述方式： 结构化描述方式\n设计目标使用Verilog语言结构化描述一个32位ALU，具有以下功能：\n\n32位无符号数加法\n32位无符号数移位、32位无符号数截断\n32位数逻辑与、32位数逻辑或、32位数逻辑非、32位数逻辑异或\n\n实现情况将上述功能集成至一个顶层模块中，其中顶层模块包括：\n\n\n\n输入变量\n\n\n\n\n[31:0] a\n32位操作数1\n\n\n[31:0] b\n32位操作数2\n\n\nCI\n1位进位输入，用于加法初始进位\n\n\n[2:0] F\n3位输入，用于功能选择\n\n\n[1:0] dir\n2位输入，用于移位或截断方向的选择\n\n\n[4:0] bite\n5位输入，用于移位位数或截断位数的选择\n\n\n输出变量\n\n\n\n[31:0] S\n32位输出，用于输出结果\n\n\nCO\n1位输出，用于加法结果第33位进位输出\n\n\n实现细节主要模块加法模块加法模块采用了组间、组内并行的超前进位方式设计\n首先构造出一个1-bit全加器，在构建一个4-bit CLA组件，通过整合四个1-bit全加器和一个4-bit CLA组件，得到一个4-bit超前进位加法器。在使用四个4-bit超前进位加法器，整合而成一个16-bit超前进位加法器，最后使用两个16-bit超前进位加法器即可完成32-bit超前进位加法器。其中，超前进位模块在运算时为每一位计算提供CI的进位信息，相比较行波进位的方式，该方式能有效控制由于门电路堆叠造成的延迟时间。\n具体原理：设二进制加法器第 i 位为Ai，Bi，输出为Si，进位输入为Ci，进位输出为C(i+1)，则有：\n四位超前进位模块公式：\n四位超前进位模块：\n四位超前进位加法器\n封装后的四位超前进位加法器：\n因为通过类比法可得：\n十六位超前进位加法器：\n三十二位超前进位加法器：\n移位模块采用门电路设计，由 1bit 移位模块、2bit 移位模块、4 bit 移位模块、8 bit 移位模块、16 bit 移位模块共五个模块构成 32 位移位模块。\n移位功能分为四种不同的类型，分别为逻辑左移、逻辑右移、循环左 移和循环右移。根据输入的两位操作数 dir 来调用不同的功能，之后再根据输入的 5 位操作数 bite 来判断移位的位数，移位位数范围从 0 到 31。\n\n逻辑左移： dir 取 00。将目标数向左移动，最低位补 0。 \n逻辑右移： dir 取 10。将目标数向右移动，最高位补 0。 \n循环左移： dir 取 01。将目标数循环左移，右侧用原符号位补齐。\n循环右移： dir 取 11。将目标数循环右移，左侧用原符号位补齐。\n\n具体原理：shifter_1bit：译码器：将输入的 2 位操作数 dir 通过译码器，输出接 wire [3:0] f，作为 功能使能信号,输出的 4 种组合中，每一种组合中只有一位输出为 1，其余三 位输出为 0。循环左移：将 32 位输入信号与功能信号 f[0],移位使能信号 enable 相与，结 果错位输出，错位距离为 1bit，例：输入第 30 位接输出第 31 位。循环右移：基本同循环左移，功能信号为 f[2],需更改错位的方向，例：输入 第 31 位接输出第 30 位。逻辑左移：功能信号为 f[1],移位后溢出的位直接丢弃，空余的位接 0 信号输 出，输入输出的每一位对应方法同循环左移。逻辑右移：功能信号为 f[3],基本同逻辑左移，只需更改接相应输入输出每一 位对应的方法。\n shifter_2bit、shifter_4bit、shifter_8bit、shifter_16bit： 基本同上， 只需将输入输出的错位距离更改为 2、4、8、16 位即可。\n截断模块本项目实现的截断功能是从目标数中截取出指定位数数据，其余位数上数据置 0。功能分为了两种不同的类型，分别为从左（高位）截取和从右（低位）截 取。根据输入的两位操作数 dir 来调用不同的功能，之后再根据输入的 5 位操作数 bite 来判断截取的位数，截取位数范围从 1 到 32，截位始端都从目标数左端或右 端开始。\n\n从右截取： dir取00。\n从左截取： dir取10。\n\n具体原理：译码器：将输入的 5 位操作数 bite 通过译码器，输出的 32 种组合中，每一种组合中 只有一位输出为 1，其余输出为 0。输出的 32 种组合与输入的 5 位变量的最小项 一一对应。\n从右截取：in 端口输入 0，若 J[n]为 1，则 J[n-1]…J[0]对应的或门输出结果都为 1，将 输出结果与输入的目标数 1 按位相与，输出 s。J[31]…J[n+1]所对应的输出都 被置为 0，而 J[n]…J[0]对应的输出保持原样。\n从左截取：in 端口输入 0，若 J[n]为 1，则 J[n-1]…J[0]对应的或门输出结果都为 1，将 输出结果与输入的目标数 1 按互补位相与，输出 s。J[n-1]…J[0]所对应的输出 都被置为 0，而 J[31]…J[n]对应的输出保持原样。\n逻辑与实现两个给定 32 位目标数之间的与运算，输出 32 位与运算后的结果。 输入两个目标数 a、b,输出结果 s。 \n具体原理：\n逻辑或实现两个给定 32 位目标数之间的或运算，输出 32 位或运算后的结果。 输入两个目标数 a、b,输出结果 s。\n具体原理：\n逻辑非实现一个给定 32 位的非运算，输出 32 位非运算后的结果。 输入一个目标数 a，输出结果 s。\n具体原理：\n逻辑异或实现两个给定 32 位目标数之间的异或运算，输出 32 位异或运算后的结果。 输入两个目标数 a、b,输出结果 s \n具体原理：\n译码器输出的 8 种组合与输入的 3 位变量的最小项一一对应。\n\n\n\n输入\n\n\n输出\n\n\n\n\n\n\n\n\n\n\nF2\nF1\nF0\nY0\nY1\nY2\nY3\nY4\nY5\nY6\nY7\n\n\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n1\n0\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n0\n0\n1\n0\n0\n0\n0\n0\n\n\n0\n1\n1\n0\n0\n0\n1\n0\n0\n0\n0\n\n\n1\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n\n\n1\n0\n1\n0\n0\n0\n0\n0\n1\n0\n0\n\n\n1\n1\n0\n0\n0\n0\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n顶层ALU模块首先设计实现不同功能的子模块，之后将这些子模块例化，集成到至同一个顶 层模块 ALU 中，然后设计译码器模块，通过译码器输入的不同来实现不同的子模 块的调用，从而实现不同的功能。 \n\n\n\n输入变量\n\n\n\n\n[31:0] a\n32位操作数1\n\n\n[31:0] b\n32位操作数2\n\n\nCI\n1位进位输入，用于加法初始进位\n\n\n[2:0] F\n3位输入，用于功能选择\n\n\n[1:0] dir\n2位输入，用于移位或截断方向的选择\n\n\n[4:0] bite\n5位输入，用于移位位数或截断位数的选择\n\n\n输出变量\n\n\n\n[31:0] S\n32位输出，用于输出结果\n\n\nCO\n1位输出，用于加法结果第33位进位输出\n\n\n功能选择\n\n\n\nF:000\n无功能，此项输出 ffffff\n\n\nF:001\n加法功能\n\n\nF:010\n移位功能\n\n\nF:011\n截断功能\n\n\nF:100\n逻辑与\n\n\nF:101\n逻辑或\n\n\nF:110\n逻辑非\n\n\nF:111\n逻辑异或\n\n\n明细表细节明细表\n\n\n模块名\n模块输入\n模块输出\n描述\n\n\n\nALU_Display\n*\n*\n顶层模块，调用多个子模块\n\n\nALU_32bit\na:(32bit)目标数1、b:(32bit)位目标数2、CI:加法初始进位、F:(3bit)功能选择、dir:(2bit)移位或截断使用、bite:(5bit)位数选择\nS:(32bit)结果输出、CO:加法结果进位\n顶层模块，调用多个子模块\n\n\nDecoder_3To8\na:(3bit)顶层模块 、F输入\ny:(8bit)与子模块输出相与\n译码器\n\n\nCLA_Add_32bit\nA:(32bit)目标数 1 输入、B:(32bit)目标数 2 输入、CI:初始进位输入\nS:(32bit)加法结果输出、CO:加法结果进 位输出\n超前进位加法器\n\n\nShifter_32bit\na:(32bit)目标数1输入、dir:(2bit)方向或功能判断、bite:(5bit)移位位数\nresult:(32bit)移位结果输出\n移位模块\n\n\nDecoder_2To4\na:(2bit)移位器子模块dir输入\ny:(4bit)与子模 块目标数 1 相与\n译码器\n\n\nTruncate_32bit\na:(32bit)目标数1输入、dir:方向判断、bite:(5bit)位数确定\ns:(32bit)截断结果输出\n截断模块\n\n\nCut_decoder\nbite:(5bit)位数输入\njudge:(32bit) 译码结果输出\n截断模块子模块\n\n\nCutL\ndir:作为0使用、a:目标数1输入、 judge:(32bit)译码结果输入\ns:(32bit)从左端点开始截断结 果输出\n左截断\n\n\nCutR\ndir:取反，作为 0 使、a:目标数1输入、judge:(32bit)译码结果输入\ns:(32bit)从右端点开始截断结果输出\n截断器子模块：从右截断\n\n\nAnd_32bit\na:(32bit)目标数 1 输入、b:(32bit)目标数 2 输入\ns:(32bit)逻辑与结果输出\n逻辑与\n\n\nOr_32bit\na:(32bit)目标数 1 输入、b:(32bit)目标数 2 输入\ns:(32bit)逻辑或结果输出\n逻辑或\n\n\nNot_32bit\na:(32bit)目标数 1 输入\ns:(32bit)逻辑非结果输出\n逻辑非\n\n\nXor_32bit\na:(32bit)目标数 1 输入、b:(32bit)目标数 2 输入\ns:(32bit)逻辑异或结果输出\n逻辑异或\n\n\n","categories":["projects"],"tags":["Vivado","Verilog"]},{"title":"鸢尾花分类的随机森林实现及结果可视化","url":"/sklearn_RF.html","content":"基于scikit-learn的鸢尾花分类及结果可视化教程（随机森林实现）。\n\n\n随机森林概述随机森林主要应用于回归和分类两种场景，又侧重于分类。\n随机森林是指利用多棵树对样本数据进行训练、分类并预测的一种方法。它在对数据进行分类的同时，还可以给出各个变量的重要性评分，评估各个变量在分类中所起的作用。\n随机森林的构建：首先利用bootstrap方法有放回地从原始训练集中随机抽取n个样本，并构建n个决策树；然后假设在训练样本数据中有m个特征，那么每次分裂时选择最好的特征进行分裂，每棵树都一直这样分裂下去，直到该节点的所有训练样例都属于同一类；接着让每棵决策树在不做任何修剪的前提下最大限度地生长；最后将生成的多棵分类树组成随机森林，用随机森林分类器对新的数据进行分类与回归。\n预测结果：\n对于分类问题，按多棵树分类器投票决定最终分类结果\n对于回归问题，则由多棵树预测值的均值决定最终预测结果\n\n分类包含两个特征的数据集本章节末有完整源代码，点此处跳转。以下为代码各部分详解。\n导入模块、函数需要使用到的模块\n\nnumpy：数据处理\nmatplotlib：结果可视化\nsklearn：具有各种分类、回归和聚类算法\n\n这里我只导入需要的部分函数\nimport numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.ensemble import ExtraTreesClassifierfrom sklearn.datasets import load_iris\n\n构建随机森林使用RandomForestClassifier函数构建随机森林分类器。\n以下为该函数的部分参数解析：\n\nn_estimators: integer (default = 100)森林中基评估器的数量，也就是树的数量。一般来说，n_estimators 越小越容易过拟合，越大模型效果越好，但达到一定程度时，再增大 n_estimators 所提升的性能非常小，并且需要注意，n_estimators 越大模型的计算量越大。sklearn 在0.22版本后，n_estimators 的默认值由原来的10增加到了100。\n\nn_jobs: integer (default = None)训练和预测时工作的CPU核心数。默认为 None，解释为n_jobs = 1。如果设置为-1，则使用所有核心进行计算。\n\nbootstrap: bool (default = True)是否使用 bootstrap 方法构建分类决策树。bootstrap 是统计学上一种非常实用的方法，通过在n个样本的集合中有放回的抽取n个样本形成一个数据集。假设样本集中有n个样本，每次抽中其中任何一个样本的概率都为1/n，即等概率，一个样本在每次抽样中没被抽中的概率为1-1/n。由于是有放回的抽样，每两次抽样之间是独立的，因此对于连续n次抽样，一个样本没被抽中的概率为：**(1−1∕n)ⁿ**\n当n趋于无穷大时，可得：lim 𝑛→+∞ (1−1∕n)ⁿ = 1∕℮，即数据集中有大约1/3的数据是没有被选取的，称为袋外数据 (out-of-bag data)。\n\noob_score: bool (default = True)\n是否使用做袋外数据进行测试。由于构建分类决策树时使用了 bootstrap 方法，所以在生成一棵树的过程中可能会有袋外数据。因此，可以不划分训练集和测试集，而通过袋外数据评估树的准确度，所有树的准确度取平均值就是该随机森林的性能。但是这不是绝对的， 如果没有数据在袋外，即数据都被某些树使用了，也就不能使用oob数据进行测试了。\n\n\nRF = RandomForestClassifier(n_jobs=4)# 即 RF = RandomForestClassifier(n_estimators=100, n_jobs=4, bootstrap=True, oob_score=True)iris = load_iris()x = iris.data[:, :2]\t# 只有两个特征y = iris.targetRF.fit(x, y)\n\n输出可视化结果使用 matplotlib 模块画出预测结果的图像，有利于直观地查看分类结果。\n本文没有划分测试集进行预测，且本小节侧重于可视化的方法教程，因此此处直接将所有数据按其标签进行可视化。\n但是，我们仍可以使用袋外数据评估分类器性能。\ncmap_bold = ListedColormap([&#x27;#FF0000&#x27;, &#x27;#00FF00&#x27;, &#x27;#0000FF&#x27;])plt.figure()plt.scatter(x[:, 0], x[:, 1], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.title(&#x27;RandomForestClassifier&#x27;)plt.show()print(&#x27;RandomForestClassifier score:&#x27;, RF.score(x, y))\n\n输出如下\n\n\n画出特征组合的决策边界为了进一步了解特征与类别的关系，还可以画出特征组合的决策边界。\n首先在一个区域里生成大量的坐标点。这需要使用 np.meshgrid() 函数。给定两个 array，比如 x=[1,2,3] 和 y=[4,5]，np.meshgrid(x,y) 会输出两个矩阵。\n# examplex = [1, 2, 3]y = [4, 5]z = np.meshgrid(x, y)print(z)\n\n输出如下\n[array([[1, 2, 3],       [1, 2, 3]]),  array([[4, 4, 4],       [5, 5, 5]])]\n\n不妨将区域边界规定为特征值的max + 1 以及 min - 1。同时使每个相邻坐标点之间的距离为 0.02。\n将所有坐标点的 x 轴数值记录在矩阵 xx 中，所有坐标点的 y 轴数值记录在矩阵 yy 中。\nx_min, x_max = x[:, 0].min() - 1, x[:, 0].max() + 1y_min, y_max = x[:, 1].min() - 1, x[:, 1].max() + 1h = .02xx, yy = np.meshgrid(        np.arange(x_min, x_max, h),        np.arange(y_min, y_max, h)    )\n\n然后，为了预测这些坐标点对应的分类，需要将所有坐标点储存为一个一维向量，同时向量的每一个元素又包含了该坐标点的x和y轴数值。\n因此，使用 np.ndarray.ravel() 函数将 xx 和 yy 矩阵各拼接为一个一维向量，再使用 np.c_() 把对应位置的数值粘合在一起。并把预测结果储存在一个一维向量 z 中。\nz = RF.predict(np.c_[xx.ravel(), yy.ravel()])\n\n为了能将预测结果对应区域的每一个坐标点，还需要将一维向量 z 转换成 xx 和 yy 的形式。\nz = z.reshape(xx.shape)\n\n最后，使用 ListedColormap() 函数接收颜色的RGB代码，以生成一个自定义的 colormap，pcolormesh() 会根据 z 的值(0, 1, 2) 来选择colormap里对应的颜色进行背景填充。\n如果需要限制画图区域，调用 plt.xlim() 和 plt.ylim() 即可。\ncmap_light = ListedColormap([&#x27;#FFAAAA&#x27;, &#x27;#AAFFAA&#x27;, &#x27;#AAAAFF&#x27;])plt.figure()plt.pcolormesh(xx, yy, z, cmap=cmap_light)plt.xlim(x[:, 0].min() - 0.5, x[:, 0].max() + 0.5)plt.ylim(x[:, 1].min() - 0.5, x[:, 1].max() + 0.5)\n\n输出如下\n\n\n完整源代码# coding: utf-8import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.ensemble import ExtraTreesClassifierfrom sklearn.datasets import load_irisRF = RandomForestClassifier(n_jobs=4)iris = load_iris()x = iris.data[:, :2]y = iris.targetRF.fit(x, y)x_min, x_max = x[:, 0].min() - 1, x[:, 0].max() + 1y_min, y_max = x[:, 1].min() - 1, x[:, 1].max() + 1h = .02cmap_bold = ListedColormap([&#x27;#FF0000&#x27;, &#x27;#00FF00&#x27;, &#x27;#0000FF&#x27;])cmap_light = ListedColormap([&#x27;#FFAAAA&#x27;, &#x27;#AAFFAA&#x27;, &#x27;#AAAAFF&#x27;])xx, yy = np.meshgrid(    np.arange(x_min, x_max, h),    np.arange(y_min, y_max, h))z = RF.predict(np.c_[xx.ravel(), yy.ravel()])z = z.reshape(xx.shape)plt.figure()plt.pcolormesh(xx, yy, z, cmap=cmap_light)plt.scatter(x[:, 0], x[:, 1], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.xlim(x[:, 0].min() - 0.5, x[:, 0].max() + 0.5)plt.ylim(x[:, 1].min() - 0.5, x[:, 1].max() + 0.5)plt.title(&#x27;RandomForestClassifier&#x27;)plt.show()print(&#x27;RandomForestClassifier score:&#x27;, RF.score(x, y))\n\n 输出结果如下\n\n\n分类包含四个特征的数据集，并画出所有特征组合的决策边界因为鸢尾花数据集中只有4个特征，所以只需要将 x = iris.data[:, :2] 改为 x = iris.data[:, :]，即可构建具有四个特征的随机森林。\n同时因为可视化更适用于 1～3 维度的数据，所以此处取两个特征为一组，共六组特征组合。\n在分类包含两个特征的数据集的代码基础上，写出如下代码\n# coding: utf-8import  numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.ensemble import ExtraTreesClassifierfrom sklearn.datasets import load_irisiris = load_iris()x = iris.data[:, :]x_01 = x[:, :2]x_02 = np.c_[x[:, 0], x[:, 2]]x_03 = np.c_[x[:, 0], x[:, 3]]x_12 = np.c_[x[:, 1], x[:, 2]]x_13 = np.c_[x[:, 1], x[:, 3]]x_23 = np.c_[x[:, 2], x[:, 3]]y = iris.targetRF_all = RandomForestClassifier(n_jobs=4)RF_01 = RandomForestClassifier(n_jobs=4)RF_02 = RandomForestClassifier(n_jobs=4)RF_03 = RandomForestClassifier(n_jobs=4)RF_12 = RandomForestClassifier(n_jobs=4)RF_13 = RandomForestClassifier(n_jobs=4)RF_23 = RandomForestClassifier(n_jobs=4)RF_all.fit(x, y)RF_01.fit(x_01, y)RF_02.fit(x_02, y)RF_03.fit(x_03, y)RF_12.fit(x_12, y)RF_13.fit(x_13, y)RF_23.fit(x_23, y)x0_min, x0_max = x[:, 0].min() - 1, x[:, 0].max() + 1x1_min, x1_max = x[:, 1].min() - 1, x[:, 1].max() + 1x2_min, x2_max = x[:, 2].min() - 1, x[:, 2].max() + 1x3_min, x3_max = x[:, 3].min() - 1, x[:, 3].max() + 1h = .02xx_01, yy_01 = np.meshgrid(    np.arange(x0_min, x0_max, h),    np.arange(x1_min, x1_max, h))xx_02, yy_02 = np.meshgrid(    np.arange(x0_min, x0_max, h),    np.arange(x2_min, x2_max, h))xx_03, yy_03 = np.meshgrid(    np.arange(x0_min, x0_max, h),    np.arange(x3_min, x3_max, h))xx_12, yy_12 = np.meshgrid(    np.arange(x1_min, x1_max, h),    np.arange(x2_min, x2_max, h))xx_13, yy_13 = np.meshgrid(    np.arange(x1_min, x1_max, h),    np.arange(x3_min, x3_max, h))xx_23, yy_23 = np.meshgrid(    np.arange(x2_min, x2_max, h),    np.arange(x3_min, x3_max, h))z_01 = RF_01.predict(np.c_[xx_01.ravel(), yy_01.ravel()])z_01 = z_01.reshape(xx_01.shape)z_02 = RF_02.predict(np.c_[xx_02.ravel(), yy_02.ravel()])z_02 = z_02.reshape(xx_02.shape)z_03 = RF_03.predict(np.c_[xx_03.ravel(), yy_03.ravel()])z_03 = z_03.reshape(xx_03.shape)z_12 = RF_12.predict(np.c_[xx_12.ravel(), yy_12.ravel()])z_12 = z_12.reshape(xx_12.shape)z_13 = RF_13.predict(np.c_[xx_13.ravel(), yy_13.ravel()])z_13 = z_13.reshape(xx_13.shape)z_23 = RF_23.predict(np.c_[xx_23.ravel(), yy_23.ravel()])z_23 = z_23.reshape(xx_23.shape)cmap_bold = ListedColormap([&#x27;#FF0000&#x27;, &#x27;#00FF00&#x27;, &#x27;#0000FF&#x27;])cmap_light = ListedColormap([&#x27;#FFAAAA&#x27;, &#x27;#AAFFAA&#x27;, &#x27;#AAAAFF&#x27;])plt.subplot(2, 3, 1)plt.pcolormesh(xx_01, yy_01, z_01, cmap=cmap_light)plt.scatter(x[:, 0], x[:, 1], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.xlim(x[:, 0].min() - 0.5, x[:, 0].max() + 0.5)plt.ylim(x[:, 1].min() - 0.5, x[:, 1].max() + 0.5)plt.title(&#x27;feature 0 &amp; 1&#x27;)plt.subplot(2, 3, 2)plt.pcolormesh(xx_02, yy_02, z_02, cmap=cmap_light)plt.scatter(x[:, 0], x[:, 2], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.xlim(x[:, 0].min() - 0.5, x[:, 0].max() + 0.5)plt.ylim(x[:, 2].min() - 0.5, x[:, 2].max() + 0.5)plt.title(&#x27;feature 0 &amp; 2&#x27;)plt.subplot(2, 3, 3)plt.pcolormesh(xx_03, yy_03, z_03, cmap=cmap_light)plt.scatter(x[:, 0], x[:, 3], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.xlim(x[:, 0].min() - 0.5, x[:, 0].max() + 0.5)plt.ylim(x[:, 3].min() - 0.5, x[:, 3].max() + 0.5)plt.title(&#x27;feature 0 &amp; 3&#x27;)plt.subplot(2, 3, 4)plt.pcolormesh(xx_12, yy_12, z_12, cmap=cmap_light)plt.scatter(x[:, 1], x[:, 2], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.xlim(x[:, 1].min() - 0.5, x[:, 1].max() + 0.5)plt.ylim(x[:, 2].min() - 0.5, x[:, 2].max() + 0.5)plt.title(&#x27;feature 1 &amp; 2&#x27;)plt.subplot(2, 3, 5)plt.pcolormesh(xx_13, yy_13, z_13, cmap=cmap_light)plt.scatter(x[:, 1], x[:, 3], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.xlim(x[:, 1].min() - 0.5, x[:, 1].max() + 0.5)plt.ylim(x[:, 3].min() - 0.5, x[:, 3].max() + 0.5)plt.title(&#x27;feature 1 &amp; 3&#x27;)plt.subplot(2, 3, 6)plt.pcolormesh(xx_23, yy_23, z_23, cmap=cmap_light)plt.scatter(x[:, 2], x[:, 3], c=y, cmap=cmap_bold, edgecolors=&#x27;k&#x27;, s=20)plt.xlim(x[:, 2].min() - 0.5, x[:, 2].max() + 0.5)plt.ylim(x[:, 3].min() - 0.5, x[:, 3].max() + 0.5)plt.title(&#x27;feature 2 &amp; 3&#x27;)plt.tight_layout()plt.show()print(&#x27;RF_all score:&#x27;, RF_all.score(x, y))print(&#x27;RF_01 score:&#x27;, RF_01.score(x_01, y))print(&#x27;RF_02 score:&#x27;, RF_02.score(x_02, y))print(&#x27;RF_03 score:&#x27;, RF_03.score(x_03, y))print(&#x27;RF_12 score:&#x27;, RF_12.score(x_12, y))print(&#x27;RF_13 score:&#x27;, RF_13.score(x_13, y))print(&#x27;RF_23 score:&#x27;, RF_23.score(x_23, y))\n\n输出结果如下\n\n\n","categories":["notes"],"tags":["random forest"]}]